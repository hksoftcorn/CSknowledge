[TOC]

# 정보처리기사

## 1과목 : 소프트웨어 설계

### 1.1. 요구사항 확인

#### 1.1.1. 소프트웨어 생명주기

SW개발 단계 별 요구되는 골격(개발 계획 및 비용), 표준화, 프로젝트 관리를 용이하게 합니다.

> - 폭포수형 모형 : 순차적, 완료 후 다음 단계로 진행, 요구사항 분명
>   - 계획 - 요구분석 - 설계 - 구현 - 테스트 - 유지보수
> - 프로토타입 모형 : 요구사항이 정확하지 않을 때, 모형을 간단히 만들어 사용자에게 보여주고 의견 반영
> - 나선형 모형 : 복잡하고, 비용 크고, 대규모 프로젝트
>   - 계획수립 - 위험분석 - 개발 - 고객평가
> - 애자일 : 고객과의 소통에 초점을 맞춘 방법론, 소규모 프로젝트, 우선순위
>   - 개인상호작용, 문서x/계약x/계획x
>   - 12가지 실험지침 : 고객만족, 적극수용, 매주 ,고객, 얼굴을 맞대고, 작동 SW, 단순화 



#### 1.1.2. 요구사항 확인

플랫폼이란, 하드웨어와 소프트웨어의 결합을 말합니다. *pass*

**분석모델**에 대해 확인하고 현행 시스템에 대해 분석합니다.

> - 환경분석
> - 운영체제 : 컴퓨터 - 윈도우, 맥, 리눅스 / 스마트폰 - IOS, 안드로이드
> - 저장장치
> - 네트워크 : 분산되어 있는 컴퓨터를 통신망으로 연결
>   - OSI 7 layer = 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층
> - DBMS : 중복성 통제, 데이터 공유, 데이터 접근 통제, 인터페이스 제공
> - 가상화

**현행 시스템 파악**

> - 1단계 : 시스템 구성, 기능, 인터페이스 파악
> - 2단계 : 아키텍처 구성, 소프트웨어 구성 파악
> - 3단계 : 하드웨어 구성, 네트워크 구성 파악



#### 1.1.3. 요구사항 작성

의뢰자가 문제를 해결하기 위한 서비스에 대한 설명, 제약 조건, SW 개발에서 기준과 근거가 되며 의사소통의 매체가 됩니다. 

> - 기술하는 내용에 따라
>   - 기능 요구사항(필수)
>   - 비기능 요구사항(필요한 것만)
> - 기술관점과 대상의 범위에 따라
>   - 시스템 요구사항
>   - 사용자 요구사항

**요구사항 도출 - 분석 - 명세 - 확인**

> - 요구사항 도출 : 수집 / 인터뷰, 설문, 워크샵, 브레인스토밍
> - 요구사항 분석 : 걸러낸다 / 타당, 비용, 일정, 범위
> - 요구사항 명세 : 문서화 / 
> - 요구사항 확인 : 확인



#### 1.1.4. UML 객체지향 언어

사용자와 개발자 사이 의사소통을 위한 언어입니다. OMG에서 표준을 정의하였고, 사물-관계-다이어그램으로 구성되어 있습니다.

> - 사물
>   - 행동 사물 : 시간, 공간, 상호작용, 상태
>   - 그룹 사물 : 그룹, 패키지
>   - 구조 사물 : 개념적, 부가적
>   - 주해 사물 :  부가적 설명
> - 관계
>   - 연관 관계 : 사물 사이 실선  사람 → 집
>   - 집합 관계 : 컴퓨터 ◇- 프린터
>   - 포함 관계 : 현관문 ◆- Key
>   - 일반화 관계 : 커피 - 아메리카노, 라떼
>   - 의존 관계 : 짧은 시간 유지
>   - 실체화 관계 : 난다 - 비행기, 새
> - 다이어그램
>   - 구조적 다이어그램(정적)
>     - 클래스, 객체
>     - 컴포넌트, 배치
>     - 복합체 구조, 패키지
>   - 행위 다이어그램(동적)
>     - 유스케이스, 시퀀스
>     - 커뮤니케이션, 상태
>     - 활동, 상호작용 개요, 타이밍



### 1.2. 화면 설계

#### 1.2.1. 화면설계 1

**사용자 인터페이스 (UI) **







### 1.3. 애플리케이션 설계

#### 1.3.1. 소프트웨어 아키텍처

원칙, 지침, 소통도구, 좋은품질(기능적, 비기능적)

> - 모듈화 : 나누기
> - 추상화 : 간략화
> - 단계적 분해 : 하향식 설계
> - 정보은닉
> - 소프트웨어 아키텍처의 품질 속성
>   - 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성
>   - 비즈니스 측면 : 시장적시성, 비용, 예상 시스템 수명
>   - 아키텍처 측면 : 개념적 무결성, 정확성, 구축 가능성, 변경, 적응

설계 과정 : 설계 목표 설정 - 시스템 타입결정 - 아키텍처 패턴 적용 - 서브시스템 구체화 - 검토

**아키텍처 패턴**

> - 전형적 해결방식, 기본적 윤곽
> - 시간 단축, 고품질, 안정적, 의사소통, 구조 이해
> - 종류
>   - 레이어 패턴
>   - 클라이언트-서버 패턴
>   - 파이프-필터 패턴 : 캡슐화 -파이프 - 전송
>   - 모델-뷰-컨트롤러 패턴(MVC)



#### 1.3.2. 객체

**객체지향**

> - 캡슐화
> - 상속
> - 추상화
> - 다형성



#### 1.3.3. 코드

식별 기능, 분류 기능, 배열 기능



#### 1.3.4. 디자인 패턴

생성패턴 5개 / 구조패턴 7개 / 행위패턴 11개

> - 생성패턴
>   - 추상팩토리 : 클래스 의존X, 연관 그룹으로 추상적으로 표현
>   - 빌더 : 조합하여 생성
>   - 팩토리 메소드 : 객체 생성 서브 클래스에서 처리, 캡슐화
>   - 프로토타입 : 원본 객체 복제
>   - 싱글톤 : 하나의 객체 생성, 어디서든 참조
> - 구조패턴
>   - 어댑터 : 호환성X 클래스를 다른 클래스가 이용 가능하도록
>   - 브리지 : 기능, 구현 별도 클래스에서 구현
>   - 컴포지트 : 복합개체, 단일 개체를 구분 없이
>   - 데코레이터 : 객체 간 결합, 능동적 기능을 확장, 부가기능 추가
>   - 퍼씨드 : 서브클래스 위에 인터페이스
>   - 플라이웨이트 : 인스턴스 매번 생성 X, 공유 하여 메모리 절약
>   - 프록시 : 접근이 어려운 객체를 연결하는 객체
> - 행위 패턴 : 상호작용 / 책임분배
>   - 책임 연쇄
>   - 커맨드
>   - 인터프리터
>   - 반복자
>   - 중재자
>   - 메멘토
>   - 옵서버
>   - 상태
>   - 전략
>   - 템플릿 메소드
>   - 방문자



### 1.4. 인터페이스 설계

#### 1.4.1. 시스템 인터페이스 요구사항 분석

인터페이스 요구사항 : 이름, 시스템, 범위 및 내용, 방식, 송신 데이터, 주기

